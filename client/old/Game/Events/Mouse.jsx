"use strict";

// Global lib imports
// import Hammer from 'hammerjs'

// Game imports
import Speeds from '../Globals/Speeds'
import Player from '../Models/Player'
import B from '../../Modules/Engine/Toolbox'

export function setup(group) {

	// create a manager for that element
	let mc = new Hammer.Manager(group.canvas, {
		recognizers: [
			// RecognizerClass, [options], [recognizeWith, ...], [requireFailure, ...]
			[Hammer.Pan],
			[Hammer.Tap],
			[Hammer.Rotate],
			[Hammer.Pinch, {enable: false}, ['rotate']],
			[Hammer.Swipe, {direction: Hammer.DIRECTION_HORIZONTAL}],
		]
	});

	// Save static speeds for now
	// TODO: Add dynamic movement speeds dependant on the size of the users group

	let player = Player.current();

	/**
	 * Used for an arc-rotate camera
	 * @param e  Event generated by Hammerjs
	 */
	let absoluteControl = (e) => {
		return B.vector3().addInPlace(B.vector3(e.deltaY / Speeds.maxH, 0, e.deltaX / Speeds.maxW));
	};

	// subscribe to events
	mc.on('pan', e => {

		let newSelect = absoluteControl(e);

		// Maximum or minimum speed Speeds.clamping
		player.vel = BABYLON.Vector3.Clamp(player.vel.addInPlace(newSelect), Speeds.clampMin, Speeds.clampMax);
	});

	let selectScaling = 2;

	/**
	 * Handle actions which allow the user to select objects in the scene before interaction
	 */
	mc.on('tap', e => {

		// See if our tap has encountered anything in the environment
		try {
			let pickResult = group.scene.pick(e.center.x, e.center.y);

			if (pickResult.hit == true) {
				if (pickResult.pickedMesh) {

					let mesh = pickResult.pickedMesh;

					// Only select stars
					if (mesh.name.indexOf('Star') < 0) {
						return;
					}

					console.log('Selected:', mesh.name);
					mesh.scaling = (mesh.scaling.x == 1) ?
						B.vector3(selectScaling, selectScaling, selectScaling) :
						B.vector3(1, 1, 1);

				}
			}
		} catch (err) {
			console.log('Picking failed:', err);
		}
	});
}

export default {
	setup
};
