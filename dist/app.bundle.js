webpackJsonp([0],{"../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./components/Canvas/index.scss":function(e,n,t){n=e.exports=t("../node_modules/css-loader/lib/css-base.js")(),n.push([e.i,".render-canvas{position:fixed;top:0;left:0;margin:0;padding:0;width:100%;height:100%;background:#000}",""])},"./components/Canvas/index.jsx":function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function r(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var a=t("../node_modules/react/react.js"),s=t.n(a),c=t("../node_modules/react-dom/index.js"),d=t.n(c),v=t("./components/Canvas/index.scss"),l=(t.n(v),function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}()),u=function(e){function n(e){o(this,n);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.properties={},t.properties.id=t.props.id,t.properties.width=t.props.width||1024,t.properties.height=t.props.height||768,t.properties.className="render-canvas "+(t.props.class||""),t}return r(n,e),l(n,[{key:"componentDidMount",value:function(){var e=d.a.findDOMNode(this);e.width=window.innerWidth,e.height=window.innerHeight}},{key:"render",value:function(){return s.a.createElement("canvas",this.properties)}}]),n}(s.a.Component);n.a=u},"./components/Canvas/index.scss":function(e,n,t){var o=t("../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./components/Canvas/index.scss");"string"==typeof o&&(o=[[e.i,o,""]]);t("../node_modules/style-loader/addStyles.js")(o,{});o.locals&&(e.exports=o.locals)},"./containers/App/index.jsx":function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function r(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var a=t("../node_modules/react/react.js"),s=t.n(a),c=t("../node_modules/react-redux/es/index.js"),d=t("./components/Canvas/index.jsx"),v=t("./containers/Game/index.jsx"),l=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),u=function(e){function n(e){o(this,n);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.id="main-render-canvas",t}return r(n,e),l(n,[{key:"componentDidMount",value:function(){v.a.start(this.id)}},{key:"render",value:function(){return s.a.createElement(d.a,{id:this.id})}}]),n}(s.a.Component);n.a=t.i(c.b)()(u)},"./containers/Game/BaseShader.jsx":function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function r(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var a=t("../node_modules/three/build/three.module.js"),s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},c=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),d="\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec2 uv;\nattribute vec3 normal;\nattribute vec3 position;\n",v="\nprecision highp float;\n",l=function(e){function n(){arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,n);var e=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));return e.vShader="",e.fShader="",e.defines={},e.uniforms={},e.extensions={},e.material=!1,e}return r(n,e),c(n,[{key:"setup",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.material=new a.h(s({vertexShader:d+this.vShader,fragmentShader:v+this.fShader,uniforms:this.uniforms,defines:this.defines,extensions:this.extensions},e))}}]),n}(a.l);n.a=l},"./containers/Game/DragControls.jsx":function(e,n,t){"use strict";var o=t("../node_modules/hammerjs/hammer.js"),i=t.n(o),r=t("../node_modules/three/build/three.module.js"),a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},s=function e(n,t){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};o=a({maxVelocity:new r.d(100,100,100),minVelocity:new r.d(-100,-100,-100),minPosition:new r.d(-2e3,-2e3,100),maxPosition:new r.d(2e3,2e3,1e4)},o),this.minVelocity=o.minVelocity,this.maxVelocity=o.maxVelocity,this.minPosition=o.minPosition,this.maxPosition=o.maxPosition,this.object=n,this.element=t,e.prototype.setup.call(this)};s.prototype.onPan=function(e){this.object.velocity.x-=50*e.velocityX,this.object.velocity.y+=50*e.velocityY},s.prototype.onPinch=function(e){this.object.velocity.z+=50*e.velocityY},s.prototype.onScroll=function(e){this.object.velocity.z+=e.deltaY},s.prototype.setup=function(){var e=this;this.hammer=new i.a(this.element),this.hammer.get("pinch").set({enable:!0}),this.hammer.on("pan",function(n){e.onPan(n)}),this.hammer.on("pinch",function(n){e.onPinch(n)}),this.object.velocity=this.object.velocity||new r.d(0,0,0),this.element.addEventListener("mousewheel",function(n){e.onScroll(n)})},s.prototype.update=function(e){this.object.position.add(this.object.velocity.divideScalar(1.08)),this.object.velocity.clamp(this.minVelocity,this.maxVelocity),this.object.position.clamp(this.minPosition,this.maxPosition)},n.a=s},"./containers/Game/Water.jsx":function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function r(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var a=t("../node_modules/three/build/three.module.js"),s=t("./modules/Engine/index.jsx"),c=t("./containers/Game/BaseShader.jsx"),d=function(e){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,n);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e)),r=new a.k(e.width,e.height,200,200);t.vShader=l,t.fShader=v,t.time=0,s.a.register(function(){t.uniforms.time.value=5e-4*performance.now()}),t.uniforms={time:{type:"f",value:t.time},heightmap:{type:"t",value:e.watermap},cPosition:{type:"v3",value:e.camera.position},worldSize:{type:"f",value:e.terrain.defines.WORLD_SIZE_X}},t.setup({});var c=new a.g(r,t.material);return c.frustumCulled=!1,t.add(c),t}return r(n,e),n}(c.a);n.a=d;var v=s.a.noise("classic2D")+"\n\nuniform float time;\nuniform vec3 cPosition;\nuniform sampler2D heightmap;\n\n\n// Color definitions\nvec3 waterA = vec3(.067, .067, .617);\nvec3 waterB = vec3(.109, .419, .627);\nvec3 waterC = vec3(.078, .160, .619);\n// vec3 waterA = vec3(2040B5\n// vec3 waterA = vec3(1C15A3\n// vec3 waterA = vec3(11119E\n// vec3 waterA = vec3(1C6BA0\n// vec3 waterA = vec3(14299E\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvoid main() {\n    float height;\n    vec4 fragHeight;\n\n    float noise200 = cnoise(200. * vUv + time);\n    float noise500 = cnoise(500. * vUv + time);\n    float noise800 = cnoise(800. * vUv + time);\n\n    // Read from the heightmap and generate an over-exposed image\n    fragHeight = texture2D(heightmap, vUv);\n    fragHeight *= 40.;\n\n    // Adding noise to the areas near land\n    if (fragHeight.b > 0.) {\n        fragHeight.rgb += cnoise(vUv * 50.) / 5.;\n    }\n\n    // Extract a floating point height value\n    fragHeight /= 10.;\n    height = fragHeight.r + fragHeight.g + fragHeight.b;\n    height += noise800 / 10.;\n\n    vec3 diffuse;\n    diffuse = mix(waterC, waterB, height);\n\n    // Add more waves near the land\n    if (height > 0.5) {\n        diffuse.b += abs(noise500) * height / 8.;\n\n        // Add sand at the edge of land\n        if (height > 0.75) {\n        }\n    }\n\n    // Basic wave frequencies\n    diffuse.b += abs(noise200 / 4.);\n    diffuse.b += abs(noise500 / 4.);\n\n    // Add many more waves near the shore\n    diffuse.b += abs(noise200 / 20.) * (height / .3);\n\n    // Adding the crests to the waves base on the blue bit\n    if (diffuse.b > 0.99) {\n        if (diffuse.b > 0.9999)\n            diffuse*=8.;\n\n        else if (diffuse.b > 0.995)\n            diffuse*=4.;\n\n        else\n            diffuse*=2.;\n    }\n\n    gl_FragColor = vec4(diffuse, 1.);\n}\n",l="\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nuniform float time;\nuniform vec3 cPosition;\nuniform float worldSize;\nuniform sampler2D heightmap;\n\nvoid main() {\n    vPosition = position;\n\n    // Find our world coordinates for the heightmap read\n    vUv  = vec2(cPosition.x / worldSize, cPosition.y / worldSize) / 2.;\n    vUv += vec2(vPosition.x / worldSize, vPosition.y / worldSize);\n\n    // Move the map so that we get more waves on certain areas of the map\n    vUv -= 0.005;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.);\n}\n"},"./containers/Game/clouds.jsx":function(e,n,t){"use strict";var o=t("../node_modules/three/build/three.module.js"),i=t("./modules/Utils.jsx"),r=t("./modules/Engine/index.jsx"),a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},s="\nuniform float time;\n\nattribute float size;\nattribute vec3 offset;\n\nvarying vec2  vUv;\nvarying float randomChoice;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n\n    vUv = uv;\n    randomChoice = rand(normalize(offset.xy)) * 3.;\n\n    vec4 mvPosition = modelViewMatrix * vec4(offset, 1.0);\n\n    // Performing the scaling operation\n    mvPosition.xy  += position.xy * size * 3.;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n",c="\n// precision highp float;\n\n// Our texture\nuniform float time;\nuniform sampler2D cloud01;\nuniform sampler2D cloud02;\nuniform sampler2D cloud03;\n\nvarying vec2  vUv;\nvarying float randomChoice;\n\nvoid main() {\n    vec4 diffuse;\n    vec2 flippedUv = vUv;\n\n    diffuse = texture2D(cloud01, fract(randomChoice) > 0.5 ? vUv : -vUv);\n\n    // Add distance fog\n    gl_FragColor = diffuse;\n}\n",d=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i.a.options(e,{xFlow:0,yFlow:0,size:35,width:1024,depth:1024,height:1024,pos:[0,0,0],blocks:1e3,minChunks:3,maxChunks:10,blockSize:10,chunkSize:!1}),e.chunkSize||(e.chunkSize=Math.max(e.width,e.height)/60),e.blockSize||(e.blockSize=Math.max(e.width,e.height)/600);var n=r.a.group.get(),t=new o.e;t.copy(new o.i(1,6));var d=[];for(var v in e.textures)d[v]={type:"t",value:e.textures[v]};var l=new o.j({depthTest:!0,depthWrite:!1,transparent:!0,vertexShader:s,fragmentShader:c,uniforms:a({},d,{time:{value:0}}),defines:{WORLD_SIZE:e.worldSize.toFixed(1)}});e.halfWidth=e.width/2,e.halfHeight=e.height/2;for(var u=new o.f(new Float32Array(e.blocks*e.maxChunks),1,1),f=new o.f(new Float32Array(e.blocks*e.maxChunks*3),3,1),x=void 0,p=void 0,g=void 0,m=void 0,h=void 0,y=void 0,w=0;w<e.blocks*e.maxChunks*3;){x=e.width*Math.random()-e.halfWidth,p=e.height*Math.random()-e.halfHeight,g=e.depth*Math.random(),m=Math.random()*e.blockSize-e.blockSize/2,h=Math.random()*e.blockSize-e.blockSize/2,y=Math.random()*e.blockSize-e.blockSize/2;for(var z=(Math.random()+.5)*e.chunkSize,P=0;P<Math.floor(Math.random()*e.maxChunks)+e.minChunks;P++,w+=3)f.setXYZ(w,x+Math.random()*e.blockSize+m,g+Math.random()*e.blockSize+y,p+Math.random()*e.blockSize+h),u.setX(w,z+.2*(Math.random()*z-z/2))}t.addAttribute("size",u),t.addAttribute("offset",f);var b=new o.g(t,l);b.frustumCulled=!1;var _=function(){l.uniforms.time.value=5e-5*performance.now()};return b.dispose=function(){r.a.unregister(n.renderID)},b.renderID=r.a.register(_),b.scale.set(1,e.depth/Math.max(e.width,e.height),1),b.position.fromArray(e.pos),b.rotation.x=Math.PI/2,b};n.a={create:d}},"./containers/Game/index.jsx":function(e,n,t){"use strict";function o(e){return function(){var n=e.apply(this,arguments);return new Promise(function(e,t){function o(i,r){try{var a=n[i](r),s=a.value}catch(e){return void t(e)}return a.done?void e(s):Promise.resolve(s).then(function(e){o("next",e)},function(e){o("throw",e)})}return o("next")})}}function i(e){console.log(e)}function r(e){u||(u=e),c.a.register(i,"hot-reload"),l(e)}var a=t("./containers/Game/input.jsx"),s=t("./containers/Game/render.jsx"),c=t("./modules/Engine/index.jsx"),d=(t("./containers/Planet/index.jsx"),t("./containers/Game/island.jsx")),v=void 0,l=function(){var e=o(regeneratorRuntime.mark(function e(n){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return v=c.a.group.create(n),e.next=3,d.a.load();case 3:t=e.sent,v.scene.add(t),v.engine.setClearColor(4748221),a.a.init(t),s.a.init();case 8:case"end":return e.stop()}},e,this)}));return function(n){return e.apply(this,arguments)}}(),u=!1;n.a={start:r}},"./containers/Game/input.jsx":function(e,n,t){"use strict";var o=t("../node_modules/hammerjs/hammer.js"),i=t.n(o),r=t("./modules/Engine/index.jsx"),a=void 0,s=void 0,c=void 0,d=void 0,v=function(){window.addEventListener("resize",l)},l=function(){c=window.innerWidth/2,d=window.innerHeight/2,a.camera.aspect=window.innerWidth/window.innerHeight,a.camera.updateProjectionMatrix(),a.engine.setSize(window.innerWidth,window.innerHeight)},u=function(e){a.player&&(a.camera.velocity.x-=e.deltaX/8,a.camera.velocity.y+=e.deltaY/8)},f=function(e){a.player&&(a.player.position.z=Math.max(Math.min(a.player.position.z+20*e.deltaY,24*s.terrain.elevation),140))},x=function(e){a.player&&(a.player.position.z=Math.max(Math.min(a.player.position.z+40*e.deltaY,24*s.terrain.elevation),140))},p={},g=void 0,m=void 0;g=m=function(e){e=e||event,p[e.code]="keydown"==e.type};var h=function(){var e=new i.a(document.body);e.get("pinch").set({enable:!0}),e.on("pan",u),e.on("pinch",f),window.addEventListener("mousewheel",x)},y=function(){},w=function(e){a=r.a.group.get(),s=e,v(),h(),y()};n.a={init:w}},"./containers/Game/island.jsx":function(e,n,t){"use strict";function o(e){return function(){var n=e.apply(this,arguments);return new Promise(function(e,t){function o(i,r){try{var a=n[i](r),s=a.value}catch(e){return void t(e)}return a.done?void e(s):Promise.resolve(s).then(function(e){o("next",e)},function(e){o("throw",e)})}return o("next")})}}var i=t("./containers/Game/clouds.jsx"),r=t("./modules/Engine/index.jsx"),a=t("./containers/Planet/index.jsx"),s=t("./containers/Game/DragControls.jsx"),c=t("./containers/Planet/Environments/Mountains.jsx"),d=t("./containers/Game/Water.jsx"),v=t("../node_modules/three/build/three.module.js"),l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},u=1,f=2,x=4,p=function(){var e=o(regeneratorRuntime.mark(function e(n){var o,p,g,m,h,y,w,z,P,b,_,j,S,E,C,D,L,O,I,k,T,A,F,K,M,N,R,V,U,G,q,W,Z;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:o=f,p=r.a.group.get(),g=new v.a(2302769),m=0,h=new v.b(8952234,2,8e6),y="5600.",w="65536.",z=t.i(c.a)({defines:{ELEVATION:y},uniforms:{light:h}}),P=void 0,e.t0=o,e.next=e.t0===x?12:e.t0===f?14:e.t0===u?16:18;break;case 12:return P=128,e.abrupt("break",20);case 14:return P=64,e.abrupt("break",20);case 16:return P=32,e.abrupt("break",20);case 18:return P=16,e.abrupt("break",20);case 20:return e.next=22,a.a.load({models:{tree:"/assets/models/tree/Tree.obj"},textures:{watermap:"/assets/textures/watermap.png",terrain:{grass01:"/assets/textures/grass01.png",stone01:"/assets/textures/stone01.png",heightmap:"/assets/textures/heightmap5.png"},cloud:{cloud01:"/assets/textures/cloud01.png",cloud02:"/assets/textures/cloud02.png",cloud03:"/assets/textures/cloud03.png"}},terrain:l({},z,{nLevels:2,defines:{ELEVATION:y,WORLD_SIZE_X:w,WORLD_SIZE_Y:w,VIEWPORT_SIZE:w,TESSELATION:P+"."}})});case 22:b=e.sent,_=new d.a({camera:p.camera,terrain:b.terrain,width:32*b.terrain.worldSize,height:32*b.terrain.worldSize,watermap:b.textures.watermap}),j=!1,S=function(){j||(m+=.005,h.position.copy({x:b.terrain.worldSize+Math.cos(m)*b.terrain.worldSize*4,y:b.terrain.worldSize+Math.sin(m)*b.terrain.worldSize*4,z:(Math.sin(m)+2)*b.terrain.elevation*4}))},window.addEventListener("keydown",function(e){"Space"==e.code&&(j=!j,console.log(b.terrain.children[0].material.uniforms))}),r.a.register(S),E=void 0,C=void 0,D=void 0,e.t1=o,e.next=e.t1===x?32:e.t1===f?36:e.t1===u?40:44;break;case 32:return E=40,C=80,D=150,e.abrupt("break",48);case 36:return E=20,C=40,D=30,e.abrupt("break",48);case 40:return E=10,C=20,D=20,e.abrupt("break",48);case 44:return E=5,C=10,D=10,e.abrupt("break",48);case 48:L=i.a.create({width:b.terrain.worldSize,height:b.terrain.worldSize,depth:2*b.terrain.elevation,pos:[b.terrain.worldSize/2,b.terrain.worldSize/2,b.terrain.elevation/2],blocks:E,maxChunks:D,minChunks:D/2,textures:b.textures.cloud,worldSize:b.terrain.worldSize,blockSize:b.terrain.worldSize/5,chunkSize:b.terrain.worldSize/C}),b.terrain.add(L),L.renderOrder=9999,p.scene.fog=new v.c(8362469,9e-6),p.camera.up.set(0,0,1),p.camera.position.y=b.terrain.worldSize,p.camera.position.x=b.terrain.worldSize/6,p.camera.position.z=2*b.terrain.elevation,p.camera.rotation.x=Math.PI/8,O=new s.a(p.camera,document.body,{minPosition:new v.d(4*-b.terrain.worldSize,4*-b.terrain.worldSize,b.terrain.elevation/4),maxPosition:new v.d(4*b.terrain.worldSize,4*b.terrain.worldSize,5*b.terrain.elevation),minVelocity:new v.d(-1e4,-1e4,-1e4),maxVelocity:new v.d(1e4,1e4,1e4)}),I=performance.now(),r.a.register(function(){var e=performance.now();O.update(e-I),I=e,_.position.copy(p.camera.position),_.position.z=140,b.animate(p.camera.position)}),k=b.models.tree.children[0].geometry,T=new v.e,T.addAttribute("position",k.attributes.position),T.addAttribute("normal",k.attributes.normal),A=2e4,F=800,K=300,e.t2=o,e.next=e.t2===x?70:e.t2===f?72:e.t2===u?74:76;break;case 70:return A=4e4,e.abrupt("break",78);case 72:return A=2e4,e.abrupt("break",78);case 74:return A=1e4,e.abrupt("break",78);case 76:return A=5e3,e.abrupt("break",78);case 78:for(T.maxInstancedCount=A,M=new v.f(new Float32Array(A),1,1),N=new v.f(new Float32Array(3*A),3,1),G=0;G<A;)R=Math.random()*b.terrain.worldSize,V=Math.random()*b.terrain.worldSize,U=b.terrain.getElevation(R,V),U>K&&U<F&&(M.setX(G,Math.random()+.5),N.setXYZ(G,R,V,U),G++);return T.addAttribute("scale",M),T.addAttribute("offset",N),q="\n    precision highp float;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    attribute float scale;\n    attribute vec3 offset;\n    attribute vec3 normal;\n    attribute vec3 position;\n\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n\n    void main() {\n\n        vNormal = normal;\n        vPosition = offset + position * scale;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.);\n    }\n    ",W="\n    precision mediump float;\n\n    "+r.a.noise("classic2D")+"\n\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n\n    uniform vec3 light;\n\n    void main() {\n\n        vec3 diffuse;\n        diffuse = mix(vec3(0, 0.05, 0.02), vec3(0., 0.3, 0.1), cnoise(vNormal.xy + vPosition.xy / 10.));\n\n        // Add distance fog\n        float depth = gl_FragCoord.z / gl_FragCoord.w;\n        float fogAmount = smoothstep(WORLD_SIZE / 8., WORLD_SIZE * 3., depth);\n        diffuse = mix(diffuse, vec3(0.5, 0.6, 0.95), fogAmount);\n\n        if (depth > WORLD_SIZE / 4.) {\n            gl_FragColor = vec4(diffuse, 1. - depth / (WORLD_SIZE /2.));\n            return;\n        }\n\n        // Add the point light\n        vec3 vLightOffset = vPosition - light;\n        float incidence = dot(vNormal, -normalize(vLightOffset));\n        incidence = clamp(incidence, 0., 1.);\n        diffuse = mix(mix(vec3(0.1), diffuse, 0.3), diffuse * 1.8, incidence);\n\n        // Fade out trees at the edge of the far-clip\n        gl_FragColor = vec4(diffuse, 1. - fogAmount);\n    }\n    ",Z=new v.g(T,new v.h({transparent:!0,vertexShader:q,fragmentShader:W,defines:{WORLD_SIZE:b.terrain.worldSize+"."},uniforms:{light:{type:"v3",value:h.position}}})),Z.frustumCulled=!1,b.add(h),b.add(_),b.add(g),b.terrain.add(Z),e.abrupt("return",b);case 93:case"end":return e.stop()}},e,this)}));return function(n){return e.apply(this,arguments)}}();n.a={load:p}},"./containers/Game/render.jsx":function(e,n,t){"use strict";var o=t("./modules/Engine/index.jsx"),i=function(){function e(){requestAnimationFrame(e),n.render()}var n=o.a.group.get();e()};n.a={init:i}},"./containers/Planet/Environments/Mountains.jsx":function(e,n,t){"use strict";var o=t("./modules/Engine/index.jsx"),i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},r="\n\nuniform vec3 light;\n\nvarying vec2  vUv2;\nvarying vec3  vPosition;\nvarying float vDistance;\nvarying float vElevation;\nvarying float vClipFactor;\n\nvoid main() {\n    initialize();\n\n    vUv2 = uv;\n    vPosition    = _vPosition;\n    vElevation   = _vElevation / ELEVATION * 4.;\n    vClipFactor  = _vClipFactor;\n    vDistance    = distance(vec3(0., 0., cameraPosition.z / 2.), position * nodeScale + nodePosition);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(_vPosition, 1.);\n}\n",a=o.a.noise("classic2D")+"\nvarying vec2 vUv2;\nvarying vec3  vPosition;\nvarying float vDistance;\nvarying float vElevation;\nvarying float vClipFactor;\n\nuniform vec3  light;\nuniform float nodeScale;\nuniform float snowLevel;\nuniform float sandLevel;\nuniform float stoneLevel;\nuniform float grassLevel;\nuniform float elevation;\n\nuniform vec3  cPosition;\n\nuniform sampler2D grass01;\nuniform sampler2D stone01;\n\nvec3 multisample(sampler2D toSample, vec2 uv) {\n    vec3 diffuse;\n    diffuse = texture2D(toSample, uv).rgb;\n    diffuse = mix(diffuse, texture2D(toSample, uv * 10.).rgb, 0.5);\n    diffuse = mix(diffuse, texture2D(toSample, uv * 100.).rgb, 0.5);\n\n    return diffuse;\n}\n\nvec3 getNormal2() {\n    float height = getElevation(heightmap, vPosition);\n    vec3 p = vec3(vPosition.xy, height);\n    vec3 dPositiondx = dFdx(p - 0.1) * TESSELATION;\n    vec3 dPositiondy = dFdy(p + 0.1) * TESSELATION;\n\n    // The normal is the cross product of the differentials\n    return normalize(cross(dPositiondx, dPositiondy));\n}\n\nvec3 getNormal() {\n\n    float vDelta = nodeScale / (TESSELATION / (1. + vClipFactor));\n\n    vec3 vNormal = vec3(0., 0., 1.);\n    vec3 p0 = vPosition;\n\n    vec3 vDelta1 = vDelta * normalize(cross(vNormal.yzx, vNormal));\n    vec3 vDelta2 = vDelta * normalize(cross(vDelta1, vNormal));\n\n    vec3 p1 = vPosition + vDelta1;\n    vec3 p2 = vPosition + vDelta2;\n\n    // Now get the height at those points\n    p0.z = getElevation(heightmap, p0, true);\n    p1.z = getElevation(heightmap, p1, true);\n    p2.z = getElevation(heightmap, p2, true);\n\n    return normalize(cross(p2 - p0, p1 - p0));\n}\n\nvoid main() {\n\n    vec2 vUv = getUv(vPosition);\n\n    bool debug = false;\n    bool useNoise = true;\n\n    // Random elements\n    vec3 noise1 = useNoise ? vec3(cnoise(vUv * 3000.)) : vec3(0.0);\n    vec3 noise3 = useNoise ? vec3(cnoise(vUv * 50000.)): vec3(0.0);\n\n    noise1 = mix(noise1, vec3(0.), smoothstep(VIEWPORT_SIZE / 64., VIEWPORT_SIZE / 16., vDistance));\n    noise3 = mix(noise3, vec3(0.), smoothstep(VIEWPORT_SIZE / 64., VIEWPORT_SIZE / 16., vDistance));\n\n    // Colors and materials\n    vec3 snow   = vec3(0.9, 0.9, 1.0);\n    vec3 water  = vec3(0.1, 0.2, 0.4);\n\n    vec3 stone  = multisample(stone01, vUv);\n    stone = mix(stone, mix(noise1, noise3, 0.2), 0.4);\n\n    vec3 grass  = multisample(grass01, vUv);\n    grass = mix(grass, mix(noise1, noise3, 0.4), 0.2);\n\n    vec3 diffuse = stone;\n\n    // Mix sandy grass\n    diffuse = mix(diffuse, mix(vec3(0.4,0.3,0.01), mix(noise1, noise3, 0.8), 0.2), smoothstep(0., sandLevel, vElevation));\n\n    // Mix grass\n    diffuse = mix(diffuse, grass, smoothstep(sandLevel + 0.05, grassLevel, vElevation));\n\n    // Mix stone\n    diffuse = mix(diffuse, stone, smoothstep(grassLevel, stoneLevel, vElevation));\n\n    // Mix in snow\n    // Caclulate the amount of snow sticking to slopes\n    vec3 normal = getNormal();\n    diffuse = mix(diffuse, snow, smoothstep(snowLevel, snowLevel * 1.4, vElevation) * smoothstep(0.8, 0.95, normal.z));\n\n    // Add the point light\n    normal = getNormal();\n    vec3 vLightOffset = vPosition + nodePosition + cPosition - light;\n    float incidence = dot(normal, -normalize(vLightOffset));\n    incidence = clamp(incidence, 0., 1.);\n    diffuse = mix(mix(vec3(0.1), diffuse, 0.3), diffuse * 1.8, incidence);\n\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogAmount = smoothstep(WORLD_SIZE_X * vElevation, WORLD_SIZE_X * 3., depth);\n    diffuse = mix(diffuse, vec3(0.5, 0.6, 0.95), fogAmount);\n\n    if (debug) {\n        diffuse.r *= 1. + vClipFactor;\n\n        if (vUv2.x < 0.01)\n            diffuse.r *= 1. + (1.- 0.01 - vUv2.x);\n        if (vUv2.y < 0.01)\n            diffuse.r *= 1. + (1.- 0.01 - vUv2.y);\n    }\n    gl_FragColor = vec4(diffuse, 1.);\n}";n.a=function(e,n){parseInt(e.defines.ELEVATION)/2;return{material:i({},e,{extensions:{derivatives:!0},uniforms:{snowLevel:{type:"f",value:.6},stoneLevel:{type:"f",value:.5},grassLevel:{type:"f",value:.25},sandLevel:{type:"f",value:.01},light:{type:"v3",value:e.uniforms.light.position}},vertexShader:r,fragmentShader:a})}}},"./containers/Planet/OBJLoader.js":function(e,n,t){"use strict";var o=t("../node_modules/three/build/three.module.js"),i=function(e){this.manager=void 0!==e?e:o.o,this.materials=null,this.regexp={vertex_pattern:/^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,normal_pattern:/^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,uv_pattern:/^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,face_vertex:/^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,face_vertex_uv:/^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,face_vertex_uv_normal:/^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,face_vertex_normal:/^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,object_pattern:/^[og]\s*(.+)?/,smoothing_pattern:/^s\s+(\d+|on|off)/,material_library_pattern:/^mtllib /,material_use_pattern:/^usemtl /}};i.prototype={constructor:i,load:function(e,n){var t=this,i=new o.p(t.manager);i.setPath(this.path),i.load(n,function(n){t.manager.onLoad(e,t.parse(n))},t.manager.onProgress,t.manager.onError)},setPath:function(e){this.path=e},setMaterials:function(e){this.materials=e},_createParserState:function(){var e={objects:[],object:{},vertices:[],normals:[],uvs:[],materialLibraries:[],startObject:function(e,n){if(this.object&&this.object.fromDeclaration===!1)return this.object.name=e,void(this.object.fromDeclaration=n!==!1);var t=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:n!==!1,geometry:{vertices:[],normals:[],uvs:[]},materials:[],smooth:!0,startMaterial:function(e,n){var t=this._finalize(!1);t&&(t.inherited||t.groupCount<=0)&&this.materials.splice(t.index,1);var o={index:this.materials.length,name:e||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:void 0!==t?t.smooth:this.smooth,groupStart:void 0!==t?t.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){var n={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return n.clone=this.clone.bind(n),n}};return this.materials.push(o),o},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){var n=this.currentMaterial();if(n&&n.groupEnd===-1&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),e&&this.materials.length>1)for(var t=this.materials.length-1;t>=0;t--)this.materials[t].groupCount<=0&&this.materials.splice(t,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),n}},t&&t.name&&"function"==typeof t.clone){var o=t.clone(0);o.inherited=!0,this.object.materials.push(o)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,n){var t=parseInt(e,10);return 3*(t>=0?t-1:t+n/3)},parseNormalIndex:function(e,n){var t=parseInt(e,10);return 3*(t>=0?t-1:t+n/3)},parseUVIndex:function(e,n){var t=parseInt(e,10);return 2*(t>=0?t-1:t+n/2)},addVertex:function(e,n,t){var o=this.vertices,i=this.object.geometry.vertices;i.push(o[e+0]),i.push(o[e+1]),i.push(o[e+2]),i.push(o[n+0]),i.push(o[n+1]),i.push(o[n+2]),i.push(o[t+0]),i.push(o[t+1]),i.push(o[t+2])},addVertexLine:function(e){var n=this.vertices,t=this.object.geometry.vertices;t.push(n[e+0]),t.push(n[e+1]),t.push(n[e+2])},addNormal:function(e,n,t){var o=this.normals,i=this.object.geometry.normals;i.push(o[e+0]),i.push(o[e+1]),i.push(o[e+2]),i.push(o[n+0]),i.push(o[n+1]),i.push(o[n+2]),i.push(o[t+0]),i.push(o[t+1]),i.push(o[t+2])},addUV:function(e,n,t){var o=this.uvs,i=this.object.geometry.uvs;i.push(o[e+0]),i.push(o[e+1]),i.push(o[n+0]),i.push(o[n+1]),i.push(o[t+0]),i.push(o[t+1])},addUVLine:function(e){var n=this.uvs,t=this.object.geometry.uvs;t.push(n[e+0]),t.push(n[e+1])},addFace:function(e,n,t,o,i,r,a,s,c,d,v,l){var u,f=this.vertices.length,x=this.parseVertexIndex(e,f),p=this.parseVertexIndex(n,f),g=this.parseVertexIndex(t,f);if(void 0===o?this.addVertex(x,p,g):(u=this.parseVertexIndex(o,f),this.addVertex(x,p,u),this.addVertex(p,g,u)),void 0!==i){var m=this.uvs.length;x=this.parseUVIndex(i,m),p=this.parseUVIndex(r,m),g=this.parseUVIndex(a,m),void 0===o?this.addUV(x,p,g):(u=this.parseUVIndex(s,m),
this.addUV(x,p,u),this.addUV(p,g,u))}if(void 0!==c){var h=this.normals.length;x=this.parseNormalIndex(c,h),p=c===d?x:this.parseNormalIndex(d,h),g=c===v?x:this.parseNormalIndex(v,h),void 0===o?this.addNormal(x,p,g):(u=this.parseNormalIndex(l,h),this.addNormal(x,p,u),this.addNormal(p,g,u))}},addLineGeometry:function(e,n){this.object.geometry.type="Line";for(var t=this.vertices.length,o=this.uvs.length,i=0,r=e.length;i<r;i++)this.addVertexLine(this.parseVertexIndex(e[i],t));for(var a=0,r=n.length;a<r;a++)this.addUVLine(this.parseUVIndex(n[a],o))}};return e.startObject("",!1),e},parse:function(e){console.time("OBJLoader");var n=this._createParserState();e.indexOf("\r\n")!==-1&&(e=e.replace(/\r\n/g,"\n")),e.indexOf("\\\n")!==-1&&(e=e.replace(/\\\n/g,""));for(var t=e.split("\n"),i="",r="",a="",s=0,c=[],d="function"==typeof"".trimLeft,v=0,l=t.length;v<l;v++)if(i=t[v],i=d?i.trimLeft():i.trim(),s=i.length,0!==s&&(r=i.charAt(0),"#"!==r))if("v"===r)if(a=i.charAt(1)," "===a&&null!==(c=this.regexp.vertex_pattern.exec(i)))n.vertices.push(parseFloat(c[1]),parseFloat(c[2]),parseFloat(c[3]));else if("n"===a&&null!==(c=this.regexp.normal_pattern.exec(i)))n.normals.push(parseFloat(c[1]),parseFloat(c[2]),parseFloat(c[3]));else{if("t"!==a||null===(c=this.regexp.uv_pattern.exec(i)))throw new Error("Unexpected vertex/normal/uv line: '"+i+"'");n.uvs.push(parseFloat(c[1]),parseFloat(c[2]))}else if("f"===r)if(null!==(c=this.regexp.face_vertex_uv_normal.exec(i)))n.addFace(c[1],c[4],c[7],c[10],c[2],c[5],c[8],c[11],c[3],c[6],c[9],c[12]);else if(null!==(c=this.regexp.face_vertex_uv.exec(i)))n.addFace(c[1],c[3],c[5],c[7],c[2],c[4],c[6],c[8]);else if(null!==(c=this.regexp.face_vertex_normal.exec(i)))n.addFace(c[1],c[3],c[5],c[7],void 0,void 0,void 0,void 0,c[2],c[4],c[6],c[8]);else{if(null===(c=this.regexp.face_vertex.exec(i)))throw new Error("Unexpected face line: '"+i+"'");n.addFace(c[1],c[2],c[3],c[4])}else if("l"===r){var u=i.substring(1).trim().split(" "),f=[],x=[];if(i.indexOf("/")===-1)f=u;else for(var p=0,g=u.length;p<g;p++){var m=u[p].split("/");""!==m[0]&&f.push(m[0]),""!==m[1]&&x.push(m[1])}n.addLineGeometry(f,x)}else if(null!==(c=this.regexp.object_pattern.exec(i))){var h=(" "+c[0].substr(1).trim()).substr(1);n.startObject(h)}else if(this.regexp.material_use_pattern.test(i))n.object.startMaterial(i.substring(7).trim(),n.materialLibraries);else if(this.regexp.material_library_pattern.test(i))n.materialLibraries.push(i.substring(7).trim());else{if(null===(c=this.regexp.smoothing_pattern.exec(i))){if("\0"===i)continue;throw new Error("Unexpected line: '"+i+"'")}var y=c[1].trim().toLowerCase();n.object.smooth="1"===y||"on"===y;var w=n.object.currentMaterial();w&&(w.smooth=n.object.smooth)}n.finalize();var z=new o.q;z.materialLibraries=[].concat(n.materialLibraries);for(var v=0,l=n.objects.length;v<l;v++){var P=n.objects[v],b=P.geometry,_=P.materials,j="Line"===b.type;if(0!==b.vertices.length){var S=new o.r;S.addAttribute("position",new o.s(new Float32Array(b.vertices),3)),b.normals.length>0?S.addAttribute("normal",new o.s(new Float32Array(b.normals),3)):S.computeVertexNormals(),b.uvs.length>0&&S.addAttribute("uv",new o.s(new Float32Array(b.uvs),2));for(var E=[],C=0,D=_.length;C<D;C++){var L=_[C],w=void 0;if(null!==this.materials&&(w=this.materials.create(L.name),j&&w&&!(w instanceof o.t))){var O=new o.t;O.copy(w),w=O}w||(w=j?new o.t:new o.u,w.name=L.name),w.shading=L.smooth?o.v:FlatShading,E.push(w)}var I;if(E.length>1){for(var C=0,D=_.length;C<D;C++){var L=_[C];S.addGroup(L.groupStart,L.groupCount,C)}var k=new o.w(E);I=j?new LineSegments(S,k):new o.g(S,k)}else I=j?new LineSegments(S,E[0]):new o.g(S,E[0]);I.name=P.name,z.add(I)}}return console.timeEnd("OBJLoader"),z}},n.a=i},"./containers/Planet/PlanetLoader.jsx":function(e,n,t){"use strict";function o(e){return function(){var n=e.apply(this,arguments);return new Promise(function(e,t){function o(i,r){try{var a=n[i](r),s=a.value}catch(e){return void t(e)}return a.done?void e(s):Promise.resolve(s).then(function(e){o("next",e)},function(e){o("throw",e)})}return o("next")})}}var i=t("./containers/Planet/index.jsx"),r=t("./containers/Planet/Terrain/index.jsx"),a=(t("./modules/Utils.jsx"),t("./modules/Engine/index.jsx")),s=t("./containers/Planet/OBJLoader.js"),c=t("../node_modules/three/build/three.module.js"),d=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},l=function(){var e=o(regeneratorRuntime.mark(function e(n,t,o,i){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:Object.keys(i).map(function(e){console.log("Loading model set",e),t.load(e,i[e]),n.count++});case 1:case"end":return e.stop()}},e,this)}));return function(n,t,o,i){return e.apply(this,arguments)}}(),u=function(){var e=o(regeneratorRuntime.mark(function e(n,t){var o,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return o=new s.a,i={count:0},e.abrupt("return",new Promise(function(e,r){var a=0,s=function(n,t){n&&(i[n]=t,++a>=i.count&&(delete i.count,e(i)))};n.setup(o.manager,s,r),l(i,o,n,t.models)}));case 3:case"end":return e.stop()}},e,this)}));return function(n,t){return e.apply(this,arguments)}}(),f=function(){var e=o(regeneratorRuntime.mark(function e(n,t,o,i){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:Object.keys(i).map(function(e){if("object"!=v(i[e]))"string"==typeof i[e]&&(n[e]=t.load(i[e]));else{console.log("Loading texture set",e),n[e]||(n[e]={});f(n[e],t,o,i[e])}});case 1:case"end":return e.stop()}},e,this)}));return function(n,t,o,i){return e.apply(this,arguments)}}(),x=function(){var e=o(regeneratorRuntime.mark(function e(n,t){var o,i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return o=new c.n,i={},e.abrupt("return",new Promise(function(e,r){n.setup(o.manager,function(){return e(i)},r),f(i,o,n,t.textures)}));case 3:case"end":return e.stop()}},e,this)}));return function(n,t){return e.apply(this,arguments)}}(),p=function(){var e=o(regeneratorRuntime.mark(function e(n,t,o){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",new Promise(function(e,i){var a={};for(var s in o.terrain)a[s]={type:"t",value:o.terrain[s]};a.texture=o.terrain.texture,a.heightmap=o.terrain.heightmap;var c=new r.a(d({load:!1,nLevels:2,uniforms:d({},t.uniforms,a)},t.terrain));n.setup(c,function(){return e(c)},i),c.load()}));case 1:case"end":return e.stop()}},e,this)}));return function(n,t,o){return e.apply(this,arguments)}}(),g=function(){var e=o(regeneratorRuntime.mark(function e(n){var t,o,r,s,c;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=new a.a.LoadingScreen,e.next=3,u(t,n);case 3:return o=e.sent,e.next=6,x(t,n);case 6:return r=e.sent,e.next=9,p(t,n,r);case 9:return s=e.sent,c=new i.a(s,o,r),t.doneLoading(),e.abrupt("return",c);case 13:case"end":return e.stop()}},e,this)}));return function(n){return e.apply(this,arguments)}}();n.a={load:g}},"./containers/Planet/Terrain/Options.jsx":function(e,n,t){"use strict"},"./containers/Planet/Terrain/TerrainShaderMaterial.jsx":function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function r(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}function a(e,n,t){return t?e+t:e+n}var s=t("../node_modules/three/build/three.module.js"),c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},d=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),v=function e(n,t,o){null===n&&(n=Function.prototype);var i=Object.getOwnPropertyDescriptor(n,t);if(void 0===i){var r=Object.getPrototypeOf(n);return null===r?void 0:e(r,t,o)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(o)},l="\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n",u="\n/**\n * Returns the UV coordinates of the current vertex position\n * vec3 p => The translated position of the current vertex\n */\nvec2 getUv(vec3 p) {\n\n    float u = (nodePosition.x + p.x) / WORLD_SIZE_X;\n    float v = (nodePosition.y + p.y) / WORLD_SIZE_Y;\n\n    return vec2(u, v);\n}\n",f="\n\n/**\n *  Returns the height at our current vertex position\n *\n *  sampler2D sample => The texture from which to sample height data\n *  vec3 p           => The translated position of the current vertex\n */\n\n#define aDeltaE 0.99\n#define bDeltaE 1.01\n\nfloat getElevation(sampler2D sample, vec3 p) {\n    vec2 uv = getUv(p);\n    vec4 d = texture2D(sample, uv);\n    return ((d.x + d.y + d.z) / 3.0) * ELEVATION;\n}\n\nfloat getElevation(sampler2D sample, vec3 p, bool multisample) {\n    vec2 uv = getUv(p);\n    vec4 d = texture2D(sample, uv);\n    d = mix(d, texture2D(sample, vec2(uv.x * aDeltaE, uv.y * aDeltaE)), uv.y);\n    d = mix(d, texture2D(sample, vec2(uv.x * bDeltaE, uv.y * aDeltaE)), uv.y);\n    d = mix(d, texture2D(sample, vec2(uv.x * bDeltaE, uv.y * bDeltaE)), uv.x);\n    d = mix(d, texture2D(sample, vec2(uv.x * aDeltaE, uv.y * bDeltaE)), uv.x);\n    return ((d.x + d.y + d.z) / 3.0) * ELEVATION;\n}\n",x="\n/**\n * Translates the current vertex coordinates into our terrain space\n * vec3 cPosition => Current camera position\n *                   This is required to keep the detail center at the camera coordinates\n *                   and as we will mutate the mesh, to keep the terrain from flickering\n */\nvec3 getPosition(vec3 cPosition) {\n    vec3 vPosition = position;\n\n    // Scale by the size of this node\n    vPosition *= nodeScale;\n\n    // Translate by camera coordinates\n    vPosition += cPosition;\n    // vPosition += nodePosition;\n\n    vPosition.z = 0.;\n\n    return vPosition;\n}\n",p="\n/**\n * Returns true or false if the current nodeEdge matches the passed edge bitmask\n *\n * int edge => Bitmask edge to be checked against current nodeEdge\n */\nbool clipSideMatches(int edge) {\n    int e = nodeEdge / edge;\n    return 2 * ( e / 2 ) != e;\n}\n\n#define CLIP_UP 1\n#define CLIP_DN 2\n#define CLIP_LT 4\n#define CLIP_RT 8\n\n/**\n * Returns a flaoting point value of the distance of\n * the current vertex from the edge of the current NODE mesh\n * vec2 p => UV coordinates of the current vertex\n */\nfloat getClip(vec2 p) {\n    float clip;\n    float toReturn = 0.0;\n\n    if (clipSideMatches(CLIP_RT) && p.x >= 1. - CLIP_EDGE) {\n        clip     = 1.0 - clamp((1.0 - p.x) / CLIP_EDGE, 0.0, 1.0);\n        toReturn = max(clip, toReturn);\n    }\n    if (clipSideMatches(CLIP_UP) && p.y >= 1. - CLIP_EDGE) {\n        clip     = 1.0 - clamp((1.0 - p.y) / CLIP_EDGE, 0.0, 1.0);\n        toReturn = max(clip, toReturn);\n    }\n    if (clipSideMatches(CLIP_LT) && p.x <= CLIP_EDGE) {\n        clip     = 1.0 - clamp(p.x / CLIP_EDGE, 0.0, 1.0);\n        toReturn = max(clip, toReturn);\n    }\n    if (clipSideMatches(CLIP_DN) && p.y <= CLIP_EDGE) {\n        clip     = 1.0 - clamp(p.y / CLIP_EDGE, 0.0, 1.0);\n        toReturn = max(clip, toReturn);\n    }\n\n    return toReturn;\n}\n\n/**\n * Returns a correct clipped position of a vertex\n * This is required because we will mutate vertices at the edge of each NODE to align\n * with a lower detail NODE's tesselation level\n *\n * vec3 p => Current translated vertex coordinates\n */\nvec3 clipSides(vec3 p) {\n    _vClipFactor = getClip(uv);\n\n    float grid = nodeScale / TESSELATION;\n    p = floor(p / grid) * grid;\n\n    // We're not currently close to an nodeEdge\n    // nodeEdges are defined by a doubling of nodeScale for the same nodeTesselation\n    if (_vClipFactor <= 0.01) {\n        return p;\n    }\n\n    // Debugging\n    // Lower the resolution of the grid, as we're moving to a\n    // larger node from a smaller node\n    grid *= 2.;\n    vec3 p2 = floor(p / grid) * grid;\n\n    // Linearly interpolate the low-poly and high-poly vertices,\n    // depending on clipping factor, which is the distance between\n    // the two parent meshes\n    return mix(p, p2, _vClipFactor);\n}\n",g="\n/**\n * Initialize variables, translating the vertex position and calculating elevation\n * This function should be called at the beginning of your vertex shader\n */\nvoid initialize() {\n    _vPosition = clipSides(getPosition(cPosition));\n    _vElevation = getElevation(heightmap, _vPosition);\n\n    _vPosition.z = _vElevation;\n}\n",m="\nuniform sampler2D  texture;\nuniform sampler2D  heightmap;\nuniform int        nodeEdge;\nuniform float      nodeScale;\nuniform vec3       cPosition;\nuniform vec3       nodePosition;\n\n// Share these as required to fragmentshader\nvec3  _vPosition;\nfloat _vElevation;\nfloat _vClipFactor;\n"+l+u+f+x+p+g,h="\nuniform vec3 nodePosition;\nuniform sampler2D  texture;\nuniform sampler2D  heightmap;\n"+l+u+f,y="\n\nvarying vec3 currentVertexPosition;\nvoid main() {\n    // Required by Terrain\n    // Calling this initializes our parameters\n    initialize();\n\n    currentVertexPosition = _vPosition;\n\n    // Output the position\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(_vPosition, 1.);\n}\n",w="\n\nvarying vec3 currentVertexPosition;\nvoid main() {\n    gl_FragColor = texture2D(texture, getUv(currentVertexPosition));\n}\n",z=function(e){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(o(this,n),!Object.getOwnPropertyNames(e).length){var t,r;return r=t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this)),i(t,r)}var s=c({},e);s.uniforms=n.getUniforms(e),s.defines=n.getDefines(e),s.vertexShader=a(m,y,e.vertexShader),s.fragmentShader=a(h,w,e.fragmentShader);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,s));return t.type="TerrainShaderMaterial",i(t)}return r(n,e),d(n,[{key:"clone",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=v(n.prototype.__proto__||Object.getPrototypeOf(n.prototype),"clone",this).call(this);return n.mixUniforms(t,e),t}}],[{key:"getUniforms",value:function(e){var n=void 0,t=void 0;return e.uniforms&&e.uniforms.texture&&(n=e.uniforms.texture.texture||e.uniforms.texture),e.uniforms.heightmap&&(t=e.uniforms.heightmap.texture||e.uniforms.heightmap),c({},e.uniforms,{texture:{type:"t",value:n},heightmap:{type:"t",value:t},nodeEdge:{type:"i",value:e.uniforms.nodeEdge},cPosition:{type:"v3",value:e.uniforms.cPosition},nodeScale:{type:"f",value:e.uniforms.nodeScale},nodePosition:{type:"v3",value:e.uniforms.nodePosition}})}},{key:"getDefines",value:function(e){return String.prototype.toFixed=function(){return this},c({},e.defines,{CLIP_EDGE:e.defines.CLIP_EDGE.toFixed(1),ELEVATION:e.defines.ELEVATION.toFixed(1),TESSELATION:e.defines.TESSELATION.toFixed(1),WORLD_SIZE_X:e.defines.WORLD_SIZE_X.toFixed(1),WORLD_SIZE_Y:e.defines.WORLD_SIZE_Y.toFixed(1),VIEWPORT_SIZE:e.defines.VIEWPORT_SIZE.toFixed(1)})}},{key:"mixUniforms",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=n.getUniforms(t);e.uniforms=c({},e.uniforms,o)}}]),n}(s.j);n.a=z},"./containers/Planet/Terrain/index.jsx":function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function r(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var a=(t("./containers/Planet/Terrain/Options.jsx"),t("../node_modules/three/build/three.module.js")),s=t("./containers/Planet/Terrain/TerrainShaderMaterial.jsx"),c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},d=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),v=8,l=function(e){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,n);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));return e={defines:c({CLIP_EDGE:.5,ELEVATION:200,TESSELATION:32,WORLD_SIZE_X:32768,WORLD_SIZE_Y:32768,VIEWPORT_SIZE:32768},e.defines||{}),uniforms:c({texture:e.texture||{},heightmap:e.heightmap||{}},e.uniforms||{}),material:c({depthTest:!0,depthWrite:!0,wireframe:!1,transparent:!1},e.material||{}),load:e.load,nLevels:e.nLevels||3,onError:e.onError||function(e){},onLoad:e.onLoad||function(e){},onProgress:e.onProgress||function(e,n,t){},onStart:e.onStart||function(e,n,t){}},"undefined"==typeof e.load&&(e.load=!0),t.heightmap=!1,e.uniforms.heightmap?t.heightmap=e.uniforms.heightmap:e.material.uniforms&&e.material.uniforms.heightmap&&(t.heightmap=e.material.uniforms.heightmap),t.heightmap||console.warn("You have not specified a heightmap texture, without this your terrain will be flat"),e.material.uniforms.heightmap&&"t"==e.material.uniforms.heightmap.type&&(e.material.uniforms.heightmap=e.material.heightmap.value),e.material.uniforms.texture&&"t"==e.material.uniforms.texture.type&&(e.material.uniforms.texture=e.material.texture.value),t.onLoad=e.onLoad,t.onError=e.onError,t.onStart=e.onStart,t.onProgress=e.onProgress,t.nLevels=e.nLevels,t.material=e.material,t.defines=e.defines,t.uniforms=e.uniforms,t.elevation=t.defines.ELEVATION,t.viewportSize=t.defines.VIEWPORT_SIZE,t.worldSize=Math.max(t.defines.WORLD_SIZE_X,t.defines.WORLD_SIZE_Y),e.load&&t.load(),t}return r(n,e),d(n,[{key:"load",value:function(){this.renderShader=!1,this.planeGeometry=new a.k(1,1,this.defines.TESSELATION,this.defines.TESSELATION),this.planeGeometry.computeBoundingSphere(),this.updateBoundingSpheres=v,this.createSplay(),this.initializeHeightmap(),this.onLoad()}},{key:"createSplay",value:function(){var e=this,n=void 0,t=void 0,o=0,i=[],r=this.defines.VIEWPORT_SIZE/Math.pow(2,this.nLevels),s=1,c=2,d=4,v=8,l=0,u=0,f=function(e,n,t){var o=0;o|=e<l-t?d:e>l?v:0,o|=n<u-t?c:n>u?s:0,i.push({uniforms:{nodeEdge:o,nodeScale:t,nodePosition:new a.d(e+.5*t,n+.5*t)}})},x=r,p=2*r;for(f(l,u,x),f(l,u-x,x),f(l-x,u-x,x),f(l-x,u,x);++o<=this.nLevels;){for(x=r,p=2*r,n=l-p,t=u-p;n<l+x;n+=x)f(n,t,x);for(n=l+x,t=u-p;t<u+x;t+=x)f(n,t,x);for(n=l+x,t=u+x;n>l-p;n-=x)f(n,t,x);for(n=l-p,t=u+x;t>u-p;t-=x)f(n,t,x);r*=2}this.onStart("Terrain/CreateSplay",0,i.length);var g=0,m=function n(){if(g<i.length)return e.createNode(i[g]),e.onProgress("Terrain/CreateNode",g++,i.length),setTimeout(n,0)};m()}},{key:"createRenderShader",value:function(){this.uniforms.nodeEdge=0,this.uniforms.nodeScale=1,this.uniforms.cPosition=this.position,this.uniforms.nodePosition=new a.d(0,0,0),this.renderShader=new s.a(c({},this.material,{defines:c({},this.material.defines,this.defines),uniforms:c({},this.material.uniforms,this.uniforms)}))}},{key:"createNode",value:function(e){this.renderShader||this.createRenderShader(),e=c({},this.material,{uniforms:c({},this.uniforms,this.material.uniforms,e.uniforms),defines:c({},this.defines,this.material.defines,e.defines)});var n=new a.g(this.planeGeometry,this.renderShader.clone(e));n.name="TerrainNode x:"+Math.floor(e.uniforms.nodePosition.x)+" y:"+Math.floor(e.uniforms.nodePosition.y),n.terrainNode=!0,n.frustumCulled=!0,n.position.copy(e.uniforms.nodePosition),n.geometry.boundingSphere.radius=.5*e.uniforms.nodeScale,this.add(n)}},{key:"animate",value:function(e){if(this.position.x=e.x/2,this.position.y=e.y/2,this.updateBoundingSpheres%v==0){for(var n=this.children.length;n--;)this.children[n].geometry&&this.children[n].geometry.boundingSphere&&this.children[n].terrainNode&&this.children[n].geometry.boundingSphere.center.copy(this.position);this.updateBoundingSpheres=0}this.updateBoundingSpheres++}},{key:"initializeHeightmap",value:function(){if(!this.heightmap)throw"Oh shit";var e=void 0,n=void 0,t=void 0;this.onStart("Terrain/CreateHeightmap",0,100),e=this.heightmap.image,n=document.createElement("canvas"),n.width=e.width,n.height=e.height,this.onProgress("Terrain/CreateHeightmap",25,100),t=n.getContext("2d"),t.drawImage(e,0,0,n.width,n.height),this.onProgress("Terrain/CreateHeightmap",50,100),this.heightData=t.getImageData(0,0,n.width,n.height),this.heightData.rgb=this.heightData.data.length/(this.heightData.width*this.heightData.height)}},{key:"positionData",value:function(e,n){var t=new Uint8Array(this.heightData.rgb);if(e<0||n<0||e>this.defines.WORLD_SIZE_X||n>this.defines.WORLD_SIZE_Y)return t;for(var o=Math.floor(e/this.defines.WORLD_SIZE_X*this.heightData.width),i=Math.floor((1-n/this.defines.WORLD_SIZE_Y)*this.heightData.height),r=o*this.heightData.rgb+i*this.heightData.width*this.heightData.rgb,a=0;a<this.heightData.rgb;a++)t[a]=this.heightData.data[r+a];return t}},{key:"getElevation",value:function(e,n){return this.positionData(e,n).slice(0,3).reduce(function(e,n){return e+n})/765*this.elevation}},{key:"dispose",value:function(){var e=this,n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.children.map(function(e){e.geometry.dispose(),e.material.dispose()}),n&&!function(){var n=void 0;Object.keys(e.renderShader.uniforms).map(function(t){n=e.renderShader.uniforms[t],"t"==n.type&&n.value instanceof a.m&&n.value.dispose()})}(),this.renderShader.dispose(),this.planeGeometry.dispose()}}]),n}(a.l);n.a=l},"./containers/Planet/index.jsx":function(e,n,t){"use strict";function o(e){return function(){var n=e.apply(this,arguments);return new Promise(function(e,t){function o(i,r){try{var a=n[i](r),s=a.value}catch(e){return void t(e)}return a.done?void e(s):Promise.resolve(s).then(function(e){o("next",e)},function(e){o("throw",e)})}return o("next")})}}function i(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function r(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function a(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var s=t("../node_modules/three/build/three.module.js"),c=t("./containers/Planet/Terrain/index.jsx"),d=t("./containers/Planet/PlanetLoader.jsx"),v=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),l=function(e){function n(e,t,o){i(this,n);var a=r(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));return a.models=t,a.textures=o,a.terrain=e,!e instanceof c.a&&(a.terrain=new c.a(e)),a.add(a.terrain),a}return a(n,e),v(n,[{key:"dispose",value:function(){var e=this;!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.terrain.dispose(!1),Object.keys(this.textures).map(function(n){uniform=e.textures[n],uniform instanceof s.m&&uniform.dispose()})}},{key:"animate",value:function(e){this.terrain.animate(e)}}],[{key:"load",value:function(){function e(e){return n.apply(this,arguments)}var n=o(regeneratorRuntime.mark(function e(n){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,d.a.load(n);case 2:return e.abrupt("return",e.sent);case 3:case"end":return e.stop()}},e,this)}));return e}()}]),n}(s.l);n.a=l},"./index.html":function(e,n,t){e.exports=t.p+"index.html"},"./index.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t("../node_modules/react/react.js"),i=t.n(o),r=t("../node_modules/react-dom/index.js"),a=t.n(r),s=t("../node_modules/react-redux/es/index.js"),c=t("./containers/App/index.jsx"),d=t("./store/index.js"),v=t("./index.html");t.n(v);a.a.render(i.a.createElement(s.a,{store:d.a},i.a.createElement(c.a,null)),document.getElementById("root"))},"./modules/Engine/Create.jsx":function(e,n,t){"use strict";function o(e){if(Array.isArray(e)){for(var n=0,t=Array(e.length);n<e.length;n++)t[n]=e[n];return t}return Array.from(e)}var i=t("./modules/Utils.jsx"),r=t("./modules/Engine/Groups.jsx"),a=t("../node_modules/three/build/three.module.js"),s=t("./modules/Engine/Vectors.jsx"),c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},d={engine:function e(n){var e=new a.A({canvas:n,antialias:!1});return e.setPixelRatio(window.devicePixelRatio),e.setSize(window.innerWidth,window.innerHeight),e},scene:function(){return new a.y},camera:function e(n){var e=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.i(s.b)(0,0,0),new a.B(80,window.innerWidth/window.innerHeight,100,12e4));return e.velocity=new a.d,e.rVelocity=new a.d,e},light:function e(){var n,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i.a.options(t,{size:1,dist:0,power:1,pos:[0,0,0],color:16777215,type:"ambient"});var e=!1,s=r.a.get();switch(t.type.toLowerCase()){case"point":e=new a.b(t.color,t.power,t.distance);break;case"ambient":default:e=new a.a(t.color)}return(n=e.position).set.apply(n,o(t.pos)),s.scene.add(e),e}};n.a=c({},d)},"./modules/Engine/Groups.jsx":function(e,n,t){"use strict";var o=t("./modules/Engine/index.jsx"),i=t("./modules/Utils.jsx"),r=t("../node_modules/stats.js/build/stats.min.js"),a=t.n(r),s=!1,c=function(){return s},d=function(e){s=e,v(e)},v=function(e){e.renderCallbacks={},e.stats=new a.a,e.status="RUNNING",e.uid=i.a.generate_name("Group"),window.scene=e.scene,window.gl=e.engine.context,e.render=function(n){e.stats.update(),o.a.callbacks("render").call(),e.engine.render(e.scene,e.camera)},e.dispose=function(){e.status="STOPPED",e.engine.dispose();for(var n in e.renderCallbacks)e.unregister(n);e.uid==s.uid&&(s=!1)},e.player=!1,e.setPlayer=function(n){e.player=n,["position","velocity","rVelocity"].map(function(n){e.hasOwnProperty(n)||(e[n]=new THREE.Vector3)})}},l=function(e){var n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=!1,i=t.canvas,r=t.engine,a=t.scene,s=t.camera;(i=document.getElementById(e))&&(r=o.a.create.engine(i))&&(a=o.a.create.scene(),a&&n&&(s=o.a.create.camera(a)));var c={scene:a,canvas:i,engine:r,camera:s};return d(c),c};n.a={get:c,set:d,create:l}},"./modules/Engine/LoadingScreen.jsx":function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}var i=t("./modules/Engine/Groups.jsx"),r=t("./modules/Utils.jsx"),a=t("../node_modules/three/build/three.module.js"),s=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),c="\nvarying vec3 vPosition;\nvoid main() {\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}\n",d="\nvarying vec3 vPosition;\n\nuniform float loadedPct;\nuniform float resolution;\n\nvoid main() {\n\n    vec4 color = vec4(smoothstep(-.5, vPosition.x / resolution, loadedPct - 0.75));\n\n    // Move down the screen\n    color = mix(vec4(0.0), color, step(-.48, vPosition.y / resolution) - step(-.45, vPosition.y / resolution));\n    color = mix(vec4(0.0), color, step(-.48, vPosition.x / resolution) - step(.48, vPosition.x / resolution));\n\n    gl_FragColor = color;\n}",v=function(){function e(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o(this,e),r.a.options(t,{resolution:1024}),this.group=i.a.get(),this.oldScene=this.group.scene,this.oldCamera=this.group.camera,this.group.camera=new a.x(-t.resolution/2,t.resolution/2,t.resolution/2,-t.resolution/2,-100,100),this.group.camera.velocity=new a.d,this.loadedPct=0,this.group.scene=new a.y,this.plane=new a.g(new a.z(t.resolution,t.resolution),new a.j({vertexShader:c,fragmentShader:d,uniforms:{loadedPct:{type:"f",value:this.loadedPct},resolution:{type:"f",value:t.resolution}}})),this.group.camera.position.z+=20,this.group.scene.add(this.plane),this.renderLoop=requestAnimationFrame(function(){return n.animate()})}return s(e,[{key:"animate",value:function(){var e=this;this.renderLoop=requestAnimationFrame(function(){return e.animate()}),this.plane.material.uniforms.loadedPct.value=this.loadedPct,this.group.render()}},{key:"onStart",value:function(e,n,t){var o=this;this.loadedPct=0,this.renderLoop||(this.renderLoop=requestAnimationFrame(function(){return o.animate()}))}},{key:"onProgress",value:function(e,n,t){this.loadedPct=n/t,n>=t&&(console.log("loaded!"),this.manager.onLoad())}},{key:"setup",value:function(e,n,t){var o=this;this.manager=e,e.onError=function(e){return t(e)},e.onStart=function(e,n,t){return o.onStart(e,n,t)},e.onProgress=function(e,n,t){return o.onProgress(e,n,t)},e.onLoad=function(){return n.apply(void 0,arguments)}}},{key:"doneLoading",value:function(){this.group.scene=this.oldScene,this.group.camera=this.oldCamera,this.plane.geometry.dispose(),this.plane.material.dispose(),cancelAnimationFrame(this.renderLoop)}}]),e}();n.a=v},"./modules/Engine/Noise/2D.jsx":function(e,n,t){"use strict";n.a="\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n";
},"./modules/Engine/Noise/3D.jsx":function(e,n,t){"use strict";n.a="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                  dot(p2,x2), dot(p3,x3) ) );\n}\n"},"./modules/Engine/Noise/3Dgrad.jsx":function(e,n,t){"use strict";n.a="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20150104 (JcBernack)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v, out vec3 gradient)\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n    vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));\n\n    // Determine noise gradient\n    vec4 temp = m2 * m * pdotx;\n    gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n    gradient *= 42.0;\n\n    return 42.0 * dot(m4, pdotx);\n}\n"},"./modules/Engine/Noise/4D.jsx":function(e,n,t){"use strict";n.a="\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n{\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n{\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n        i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n                                       + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n                              + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n                     + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n"},"./modules/Engine/Noise/cellular2D.jsx":function(e,n,t){"use strict";n.a='\n// Cellular noise ("Worley noise") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 289 without a division (only multiplications)\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec3 mod7(vec3 x) {\n    return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n    return mod289((34.0 * x + 1.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n    #define K 0.142857142857 // 1/7\n    #define Ko 0.428571428571 // 3/7\n    #define jitter 1.0 // Less gives more regular pattern\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p*K) - Ko;\n    vec3 oy = mod7(floor(p*K))*K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter*ox;\n    vec3 dy = Pf.y - of + jitter*oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p*K) - Ko;\n    oy = mod7(floor(p*K))*K - Ko;\n    dx = Pf.x - 0.5 + jitter*ox;\n    dy = Pf.y - of + jitter*oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p*K) - Ko;\n    oy = mod7(floor(p*K))*K - Ko;\n    dx = Pf.x - 1.5 + jitter*ox;\n    dy = Pf.y - of + jitter*oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we\'re done.\n    return sqrt(d1.xy);\n}\n'},"./modules/Engine/Noise/cellular2x2.jsx":function(e,n,t){"use strict";n.a='\n#version 120\n\n// Cellular noise ("Worley noise") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 289 without a division (only multiplications)\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec4 mod7(vec4 x) {\n    return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n    return mod289((34.0 * x + 1.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2(vec2 P) {\n    #define K 0.142857142857 // 1/7\n    #define K2 0.0714285714285 // K/2\n    #define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n    vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n    vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n    p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n    vec4 ox = mod7(p)*K+K2;\n    vec4 oy = mod7(floor(p*K))*K+K2;\n    vec4 dx = Pfx + jitter*ox;\n    vec4 dy = Pfy + jitter*oy;\n    vec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n    // Sort out the two smallest distances\n    #if 0\n    // Cheat and pick only F1\n    d.xy = min(d.xy, d.zw);\n    d.x = min(d.x, d.y);\n    return vec2(sqrt(d.x)); // F1 duplicated, F2 not computed\n    #else\n    // Do it right and find both F1 and F2\n    d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n    d.xz = (d.x < d.z) ? d.xz : d.zx;\n    d.xw = (d.x < d.w) ? d.xw : d.wx;\n    d.y = min(d.y, d.z);\n    d.y = min(d.y, d.w);\n    return sqrt(d.xy);\n    #endif\n}\n'},"./modules/Engine/Noise/cellular2x2x2.jsx":function(e,n,t){"use strict";n.a='\n#version 120\n\n// Cellular noise ("Worley noise") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 289 without a division (only multiplications)\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec4 mod7(vec4 x) {\n    return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n    return mod289((34.0 * x + 1.0) * x);\n}\n\nvec4 permute(vec4 x) {\n    return mod289((34.0 * x + 1.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n    #define K 0.142857142857 // 1/7\n    #define Ko 0.428571428571 // 1/2-K/2\n    #define K2 0.020408163265306 // 1/(7*7)\n    #define Kz 0.166666666667 // 1/6\n    #define Kzo 0.416666666667 // 1/2-1/6*2\n    #define jitter 0.8 // smaller jitter gives less errors in F2\n    vec3 Pi = mod289(floor(P));\n    vec3 Pf = fract(P);\n    vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n    vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n    vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n    p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n    vec4 p1 = permute(p + Pi.z); // z+0\n    vec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n    vec4 ox1 = fract(p1*K) - Ko;\n    vec4 oy1 = mod7(floor(p1*K))*K - Ko;\n    vec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n    vec4 ox2 = fract(p2*K) - Ko;\n    vec4 oy2 = mod7(floor(p2*K))*K - Ko;\n    vec4 oz2 = floor(p2*K2)*Kz - Kzo;\n    vec4 dx1 = Pfx + jitter*ox1;\n    vec4 dy1 = Pfy + jitter*oy1;\n    vec4 dz1 = Pf.z + jitter*oz1;\n    vec4 dx2 = Pfx + jitter*ox2;\n    vec4 dy2 = Pfy + jitter*oy2;\n    vec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n    // Sort out the two smallest distances (F1, F2)\n    #if 0\n    // Cheat and sort out only F1\n    d1 = min(d1, d2);\n    d1.xy = min(d1.xy, d1.wz);\n    d1.x = min(d1.x, d1.y);\n    return vec2(sqrt(d1.x));\n    #else\n    // Do it right and sort out both F1 and F2\n    vec4 d = min(d1,d2); // F1 is now in d\n    d2 = max(d1,d2); // Make sure we keep all candidates for F2\n    d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\n    d.xz = (d.x < d.z) ? d.xz : d.zx;\n    d.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\n    d.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\n    d.y = min(d.y, d.z); // nor in d.z\n    d.y = min(d.y, d.w); // nor in d.w\n    d.y = min(d.y, d2.x); // F2 is now in d.y\n    return sqrt(d.xy); // F1 and F2\n    #endif\n}\n'},"./modules/Engine/Noise/cellular3D.jsx":function(e,n,t){"use strict";n.a='\n#version 120\n\n// Cellular noise ("Worley noise") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 289 without a division (only multiplications)\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Modulo 7 without a division\nvec3 mod7(vec3 x) {\n    return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n    return mod289((34.0 * x + 1.0) * x);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\n\nvec2 cellular(vec3 P) {\n    #define K 0.142857142857 // 1/7\n    #define Ko 0.428571428571 // 1/2-K/2\n    #define K2 0.020408163265306 // 1/(7*7)\n    #define Kz 0.166666666667 // 1/6\n    #define Kzo 0.416666666667 // 1/2-1/6*2\n    #define jitter 1.0 // smaller jitter gives more regular pattern\n\n    vec3 Pi = mod289(floor(P));\n    vec3 Pf = fract(P) - 0.5;\n\n    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n    vec3 p1 = permute(p + Pi.y - 1.0);\n    vec3 p2 = permute(p + Pi.y);\n    vec3 p3 = permute(p + Pi.y + 1.0);\n\n    vec3 p11 = permute(p1 + Pi.z - 1.0);\n    vec3 p12 = permute(p1 + Pi.z);\n    vec3 p13 = permute(p1 + Pi.z + 1.0);\n\n    vec3 p21 = permute(p2 + Pi.z - 1.0);\n    vec3 p22 = permute(p2 + Pi.z);\n    vec3 p23 = permute(p2 + Pi.z + 1.0);\n\n    vec3 p31 = permute(p3 + Pi.z - 1.0);\n    vec3 p32 = permute(p3 + Pi.z);\n    vec3 p33 = permute(p3 + Pi.z + 1.0);\n\n    vec3 ox11 = fract(p11*K) - Ko;\n    vec3 oy11 = mod7(floor(p11*K))*K - Ko;\n    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n    vec3 ox12 = fract(p12*K) - Ko;\n    vec3 oy12 = mod7(floor(p12*K))*K - Ko;\n    vec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n    vec3 ox13 = fract(p13*K) - Ko;\n    vec3 oy13 = mod7(floor(p13*K))*K - Ko;\n    vec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n    vec3 ox21 = fract(p21*K) - Ko;\n    vec3 oy21 = mod7(floor(p21*K))*K - Ko;\n    vec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n    vec3 ox22 = fract(p22*K) - Ko;\n    vec3 oy22 = mod7(floor(p22*K))*K - Ko;\n    vec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n    vec3 ox23 = fract(p23*K) - Ko;\n    vec3 oy23 = mod7(floor(p23*K))*K - Ko;\n    vec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n    vec3 ox31 = fract(p31*K) - Ko;\n    vec3 oy31 = mod7(floor(p31*K))*K - Ko;\n    vec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n    vec3 ox32 = fract(p32*K) - Ko;\n    vec3 oy32 = mod7(floor(p32*K))*K - Ko;\n    vec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n    vec3 ox33 = fract(p33*K) - Ko;\n    vec3 oy33 = mod7(floor(p33*K))*K - Ko;\n    vec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n    vec3 dx11 = Pfx + jitter*ox11;\n    vec3 dy11 = Pfy.x + jitter*oy11;\n    vec3 dz11 = Pfz.x + jitter*oz11;\n\n    vec3 dx12 = Pfx + jitter*ox12;\n    vec3 dy12 = Pfy.x + jitter*oy12;\n    vec3 dz12 = Pfz.y + jitter*oz12;\n\n    vec3 dx13 = Pfx + jitter*ox13;\n    vec3 dy13 = Pfy.x + jitter*oy13;\n    vec3 dz13 = Pfz.z + jitter*oz13;\n\n    vec3 dx21 = Pfx + jitter*ox21;\n    vec3 dy21 = Pfy.y + jitter*oy21;\n    vec3 dz21 = Pfz.x + jitter*oz21;\n\n    vec3 dx22 = Pfx + jitter*ox22;\n    vec3 dy22 = Pfy.y + jitter*oy22;\n    vec3 dz22 = Pfz.y + jitter*oz22;\n\n    vec3 dx23 = Pfx + jitter*ox23;\n    vec3 dy23 = Pfy.y + jitter*oy23;\n    vec3 dz23 = Pfz.z + jitter*oz23;\n\n    vec3 dx31 = Pfx + jitter*ox31;\n    vec3 dy31 = Pfy.z + jitter*oy31;\n    vec3 dz31 = Pfz.x + jitter*oz31;\n\n    vec3 dx32 = Pfx + jitter*ox32;\n    vec3 dy32 = Pfy.z + jitter*oy32;\n    vec3 dz32 = Pfz.y + jitter*oz32;\n\n    vec3 dx33 = Pfx + jitter*ox33;\n    vec3 dy33 = Pfy.z + jitter*oy33;\n    vec3 dz33 = Pfz.z + jitter*oz33;\n\n    vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n    vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n    vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n    vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n    vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n    vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n    vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n    vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n    vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n    // Sort out the two smallest distances (F1, F2)\n    #if 0\n    // Cheat and sort out only F1\n    vec3 d1 = min(min(d11,d12), d13);\n    vec3 d2 = min(min(d21,d22), d23);\n    vec3 d3 = min(min(d31,d32), d33);\n    vec3 d = min(min(d1,d2), d3);\n    d.x = min(min(d.x,d.y),d.z);\n    return vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n    #else\n    // Do it right and sort out both F1 and F2\n    vec3 d1a = min(d11, d12);\n    d12 = max(d11, d12);\n    d11 = min(d1a, d13); // Smallest now not in d12 or d13\n    d13 = max(d1a, d13);\n    d12 = min(d12, d13); // 2nd smallest now not in d13\n    vec3 d2a = min(d21, d22);\n    d22 = max(d21, d22);\n    d21 = min(d2a, d23); // Smallest now not in d22 or d23\n    d23 = max(d2a, d23);\n    d22 = min(d22, d23); // 2nd smallest now not in d23\n    vec3 d3a = min(d31, d32);\n    d32 = max(d31, d32);\n    d31 = min(d3a, d33); // Smallest now not in d32 or d33\n    d33 = max(d3a, d33);\n    d32 = min(d32, d33); // 2nd smallest now not in d33\n    vec3 da = min(d11, d21);\n    d21 = max(d11, d21);\n    d11 = min(da, d31); // Smallest now in d11\n    d31 = max(da, d31); // 2nd smallest now not in d31\n    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n    d12 = min(d12, d21); // 2nd smallest now not in d21\n    d12 = min(d12, d22); // nor in d22\n    d12 = min(d12, d31); // nor in d31\n    d12 = min(d12, d32); // nor in d32\n    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n    d11.y = min(d11.y,d12.z); // Only two more to go\n    d11.y = min(d11.y,d11.z); // Done! (Phew!)\n    return sqrt(d11.xy); // F1, F2\n    #endif\n}\n'},"./modules/Engine/Noise/classic2D.jsx":function(e,n,t){"use strict";n.a='\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n'},"./modules/Engine/Noise/classic3D.jsx":function(e,n,t){"use strict";n.a='\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n';
},"./modules/Engine/Noise/classic4D.jsx":function(e,n,t){"use strict";n.a='\n//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade(vec4 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec4 P)\n{\n    vec4 Pi0 = floor(P); // Integer part for indexing\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n\n// Classic Perlin noise, periodic version\nfloat pnoise(vec4 P, vec4 rep)\n{\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n'},"./modules/Engine/Noise/index.jsx":function(e,n,t){"use strict";var o=t("./modules/Engine/Noise/2D.jsx"),i=t("./modules/Engine/Noise/3D.jsx"),r=t("./modules/Engine/Noise/4D.jsx"),a=t("./modules/Engine/Noise/psrd2D.jsx"),s=t("./modules/Engine/Noise/3Dgrad.jsx"),c=t("./modules/Engine/Noise/classic2D.jsx"),d=t("./modules/Engine/Noise/classic3D.jsx"),v=t("./modules/Engine/Noise/classic4D.jsx"),l=t("./modules/Engine/Noise/cellular3D.jsx"),u=t("./modules/Engine/Noise/cellular2D.jsx"),f=t("./modules/Engine/Noise/cellular2x2.jsx"),x=t("./modules/Engine/Noise/cellular2x2x2.jsx"),p={"2D":o.a,"3D":i.a,"4D":r.a,PSRD2D:a.a,"3DGRAD":s.a,CLASSIC2D:c.a,CLASSIC3D:d.a,CLASSIC4D:v.a,CELLULAR2D:u.a,CELLULAR3D:l.a,CELLULAR2X2:f.a,CELLULAR2X2X2:x.a};n.a=function(e){if(e=e.toUpperCase(),p.hasOwnProperty(e))return p[e];throw"No noise function of "+e+" found"}},"./modules/Engine/Noise/psrd2D.jsx":function(e,n,t){"use strict";n.a='\n//\n// vec3  psrdnoise(vec2 pos, vec2 per, float rot)\n// vec3  psdnoise(vec2 pos, vec2 per)\n// float psrnoise(vec2 pos, vec2 per, float rot)\n// float psnoise(vec2 pos, vec2 per)\n// vec3  srdnoise(vec2 pos, float rot)\n// vec3  sdnoise(vec2 pos)\n// float srnoise(vec2 pos, float rot)\n// float snoise(vec2 pos)\n//\n// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no "d" in the name), without\n// the tiling property (no "p" in the name) and without the rotating\n// gradients (no "r" in the name).\n//\n// This is (yet) another variation on simplex noise. It\'s similar to the\n// version presented by Ken Perlin, but the grid is axis-aligned and\n// slightly stretched in the y direction to permit rectangular tiling.\n//\n// The noise can be made to tile seamlessly to any integer period in x and\n// any even integer period in y. Odd periods may be specified for y, but\n// then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and can\n// serve a similar purpose for animation as motion along z in 3-D noise.\n// The rotating gradients in conjunction with the analytic derivatives\n// can make "flow noise" effects as presented by Perlin and Neyret.\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// "pos" is the input (x,y) coordinate\n// "per" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// "rot" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The first component of the 3-element return vector is the noise value.\n// The second and third components are the x and y partial derivatives.\n//\n// float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot})\n// "pos" is the input (x,y) coordinate\n// "per" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// "rot" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The return value is the noise value.\n// Partial derivatives are not computed, making these functions faster.\n//\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n//\n// TODO: One-pixel wide artefacts used to occur due to precision issues with\n// the gradient indexing. This is specific to this variant of noise, because\n// one axis of the simplex grid is perfectly aligned with the input x axis.\n// The errors were rare, and they are now very unlikely to ever be visible\n// after a quick fix was introduced: a small offset is added to the y coordinate.\n// A proper fix would involve using round() instead of floor() in selected\n// places, but the quick fix works fine.\n// (If you run into problems with this, please let me know.)\n//\n\n// Modulo 289, optimizes to code without divisions\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Permutation polynomial (ring size 289 = 17*17)\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2(vec2 p, float rot) {\n    #if 0\n    // Map from a line to a diamond such that a shift maps to a rotation.\n    float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n    u = 4.0 * fract(u) - 2.0;\n    // (This vector could be normalized, exactly or approximately.)\n    return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);\n    #else\n    // For more isotropic gradients, sin/cos can be used instead.\n    float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n    u = fract(u) * 6.28318530718; // 2*pi\n    return vec2(cos(u), sin(u));\n    #endif\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n    // Hack: offset y slightly to hide some rare artifacts\n    pos.y += 0.01;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n    // wrap points in (x,y), map to (u,v)\n    vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n    vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n    vec3 iuw = xw + 0.5 * yw;\n    vec3 ivw = yw;\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Partial derivatives for analytical gradient computation\n    vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n    vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    if (t.x < 0.0) {\n        dtdx.x = 0.0;\n        dtdy.x = 0.0;\n        t.x = 0.0;\n    }\n    if (t.y < 0.0) {\n        dtdx.y = 0.0;\n        dtdy.y = 0.0;\n        t.y = 0.0;\n    }\n    if (t.z < 0.0) {\n        dtdx.z = 0.0;\n        dtdy.z = 0.0;\n        t.z = 0.0;\n    }\n\n    // Fourth power of t (and third power for derivative)\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n    vec3 t3 = t2 * t;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Final analytical derivative (gradient of a sum of scalar products)\n    vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n    vec2 dn0 = t4.x * g0 + dt0 * w.x;\n    vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n    vec2 dn1 = t4.y * g1 + dt1 * w.y;\n    vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n    vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n    return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients\n// and analytical derivative.\n// This function is implemented as a wrapper to "psrdnoise",\n// at the minimal cost of three extra additions.\n//\nvec3 psdnoise(vec2 pos, vec2 per) {\n    return psrdnoise(pos, per, 0.0);\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients,\n// but without the analytical derivative.\n//\nfloat psrnoise(vec2 pos, vec2 per, float rot) {\n    // Offset y slightly to hide some rare artifacts\n    pos.y += 0.001;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n    // wrap points in (x,y), map to (u,v)\n    vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n    vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n    vec3 iuw = xw + 0.5 * yw;\n    vec3 ivw = yw;\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    t = max(t, 0.0);\n\n    // Fourth power of t\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Rescale to cover the range [-1,1] reasonably well\n    return 11.0*n;\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to "psrnoise",\n// at the minimal cost of three extra additions.\n//\nfloat psnoise(vec2 pos, vec2 per) {\n    return psrnoise(pos, per, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 srdnoise(vec2 pos, float rot) {\n    // Offset y slightly to hide some rare artifacts\n    pos.y += 0.001;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    vec3 x = vec3(p0.x, p1.x, p2.x);\n    vec3 y = vec3(p0.y, p1.y, p2.y);\n    vec3 iuw = x + 0.5 * y;\n    vec3 ivw = y;\n\n    // Avoid precision issues in permutation\n    iuw = mod289(iuw);\n    ivw = mod289(ivw);\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Partial derivatives for analytical gradient computation\n    vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n    vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    if (t.x < 0.0) {\n        dtdx.x = 0.0;\n        dtdy.x = 0.0;\n        t.x = 0.0;\n    }\n    if (t.y < 0.0) {\n        dtdx.y = 0.0;\n        dtdy.y = 0.0;\n        t.y = 0.0;\n    }\n    if (t.z < 0.0) {\n        dtdx.z = 0.0;\n        dtdy.z = 0.0;\n        t.z = 0.0;\n    }\n\n    // Fourth power of t (and third power for derivative)\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n    vec3 t3 = t2 * t;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Final analytical derivative (gradient of a sum of scalar products)\n    vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n    vec2 dn0 = t4.x * g0 + dt0 * w.x;\n    vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n    vec2 dn1 = t4.y * g1 + dt1 * w.y;\n    vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n    vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n    return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n// This function is implemented as a wrapper to "srdnoise",\n// at the minimal cost of three extra additions.\n//\nvec3 sdnoise(vec2 pos) {\n    return srdnoise(pos, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients,\n// without the analytical derivative.\n//\nfloat srnoise(vec2 pos, float rot) {\n    // Offset y slightly to hide some rare artifacts\n    pos.y += 0.001;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n    // wrap points in (x,y), map to (u,v)\n    vec3 x = vec3(p0.x, p1.x, p2.x);\n    vec3 y = vec3(p0.y, p1.y, p2.y);\n    vec3 iuw = x + 0.5 * y;\n    vec3 ivw = y;\n\n    // Avoid precision issues in permutation\n    iuw = mod289(iuw);\n    ivw = mod289(ivw);\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    t = max(t, 0.0);\n\n    // Fourth power of t\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Rescale to cover the range [-1,1] reasonably well\n    return 11.0*n;\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to "srnoise",\n// at the minimal cost of three extra additions.\n// Note: if this kind of noise is all you want, there are faster\n// GLSL implementations of non-tiling simplex noise out there.\n// This one is included mainly for completeness and compatibility\n// with the other functions in the file.\n//\nfloat snoise(vec2 pos) {\n    return srnoise(pos, 0.0);\n}\n'},"./modules/Engine/Registry.jsx":function(e,n,t){"use strict";var o=t("./modules/Utils.jsx"),i=function(){var e=this;this.items=[],this.call=function(){for(var n=arguments.length,t=Array(n),o=0;o<n;o++)t[o]=arguments[o];e.items.map(function(e){return e.callback.apply(e,t)})},this.add=function(n){e.items.push(n)},this.rem=function(n){e.items=e.items.filter(function(e){return e.name!=n})}},r={},a=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"render";switch(n=n.toUpperCase()){case"RENDER":break;case"HOT-RELOAD":break;default:return!1}var t=o.a.generate_name("Engine_"+n+"_Callback");return r[n]||(r[n]=new i),r[n].add({name:t,callback:e}),t},s=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"render";switch(n=n.toUpperCase()){case"render":if(r[n].hasOwnProperty(e))break;default:return}delete r[n].rem(e)},c=new i,d=function(e){return e=e.toUpperCase(),r[e]?r[e]:c};n.a={register:a,unregister:s,callbacks:d}},"./modules/Engine/Vectors.jsx":function(e,n,t){"use strict";function o(e){if(Array.isArray(e)){for(var n=0,t=Array(e.length);n<e.length;n++)t[n]=e[n];return t}return Array.from(e)}var i=t("../node_modules/three/build/three.module.js");t.d(n,"b",function(){return a});var r=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0],n=Object.values(e);switch(Object.keys(e).length){case 2:return new(Function.prototype.bind.apply(i.C,[null].concat(o(n))));case 3:return new(Function.prototype.bind.apply(i.d,[null].concat(o(n))));case 4:return new(Function.prototype.bind.apply(i.D,[null].concat(o(n))));default:return new i.d}},a=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return new i.d(e,n,t)},s=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new i.C(e,n)};n.a={vector2:s,vector3:a,vectorize:r}},"./modules/Engine/index.jsx":function(e,n,t){"use strict";var o=t("./modules/Engine/Noise/index.jsx"),i=t("./modules/Engine/Groups.jsx"),r=t("./modules/Engine/Create.jsx"),a=t("./modules/Engine/Vectors.jsx"),s=t("./modules/Engine/Registry.jsx"),c=t("./modules/Engine/LoadingScreen.jsx"),d=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e};n.a=d({group:i.a,noise:o.a},a.a,{create:d({},r.a)},s.a,{LoadingScreen:c.a})},"./modules/Utils.jsx":function(e,n,t){"use strict";function o(e,n,t){var o=void 0;if(t){var i=new Date;i.setTime(i.getTime()+24*t*60*60*1e3),o="; expires="+i.toGMTString()}else o="";document.cookie=e+"="+n+o+"; path=/"}function i(e){for(var n=e+"=",t=document.cookie.split(";"),o=0;o<t.length;o++){for(var i=t[o];" "==i.charAt(0);)i=i.substring(1,i.length);if(0==i.indexOf(n))return i.substring(n.length,i.length)}return null}function r(e){o(e,"",-1);
}function a(e,n,t){return e=e||{},e&&e.hasOwnProperty(n)?e[n]:t}function s(e,n,t){return e=e||{},!!e&&(e[n]=t)}function c(e,n,t,o){return e?e.hasOwnProperty(n)?e[n]+=t||1:o?e[n]=o:e[n]=1:1}function d(e,n,t,o){return c(e,n,-t,o)}function v(e){var n=void 0;return"string"==typeof e?n=e:(e=e||{},n=a(e,"type","NoType")),n+"_"+c(x,n,1)}function l(){return"ontouchstart"in document.documentElement}function u(){}function f(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(var t in n)"undefined"==typeof e[t]&&(e[t]=n[t]);return e}var x={};n.a={get:a,set:s,inc:c,dec:d,options:f,is_mobile:l,set_cookie:o,get_cookie:i,del_cookie:r,generate_name:v,toggle_fullscreen:u}},"./reducers/index.jsx":function(e,n,t){"use strict";var o=t("../node_modules/redux/es/index.js"),i=t("./reducers/loader.jsx"),r=t("./reducers/interact.jsx");n.a=t.i(o.d)({interact:r.a,loader:i.a})},"./reducers/interact.jsx":function(e,n,t){"use strict";var o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e};n.a=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return o({},e,n)}},"./reducers/loader.jsx":function(e,n,t){"use strict";var o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e};n.a=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return o({},e,n)}},"./store/index.js":function(e,n,t){"use strict";var o=t("../node_modules/redux/es/index.js"),i=t("../node_modules/redux-thunk/lib/index.js"),r=t.n(i),a=t("./reducers/index.jsx"),s=t.i(o.b)(r.a)(o.c),c=s(a.a);n.a=c},0:function(e,n,t){t("../node_modules/babel-polyfill/lib/index.js"),e.exports=t("./index.js")}},[0]);